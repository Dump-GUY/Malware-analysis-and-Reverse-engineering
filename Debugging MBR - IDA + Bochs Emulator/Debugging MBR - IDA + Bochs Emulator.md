# Debugging MBR - IDA + Bochs Emulator (CTF example)

This post will explain how to setup Bochs Emulator to debug MBR in IDA environment on Windows OS.
It could be quite useful if we are struggling with some kind of MBR Locker/Wiper or another kind of MBR modifier where we have to
RE the bootstrap code.

A master boot record (MBR) is a special type of boot sector at the very beginning of partitioned computer mass storage devices like fixed disks or
removable drives. The MBR consists of 512 bytes located in the first sector of the drive.
We are especially interested in analyzing the Bootstrap code area which starts at file offset 0x0000.

![](media/a966dfc92126df5186101c17c0ec79de.png)

First of all, we could be in situation where we have the infected drive or already carved out MBR “bin file”. 
If we have the infected drive, we could carve out the first 512 bytes of it with some Hex editor or Unix “dd” command-line
utility etc…

As an example in this post, we will be using MBR from one of challenges
CrowdStrike Intelligence Adversary Quest CTF.<br/>
[[CrowdStrike Intelligence Adversary Quest]](https://www.crowdstrike.com/blog/join-crowdstrike-intelligence-adversary-quest/)

This challenge was called “The Proclamation”.
We simple got MBR bin file and have to obtain the right flag.<br/>
MBR to download from this challenge is available here [[MBR sample]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/Debugging%20MBR%20-%20IDA%20%2B%20Bochs%20Emulator/My_MBR).<br/>
Another real world sample of MBR wiper "WhisperGate" [[Download Here]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/Debugging%20MBR%20-%20IDA%20%2B%20Bochs%20Emulator/WhisperGate_MBR_BOCHS_CFG.7z).<br/>


## Installing Bochs Emulator

Download and install Bochs x86 PC emulator available here [[Bochs x86 PC
emulator]](https://sourceforge.net/projects/bochs/). IDA is recommending version
v2.6.x. The latest version now (30. 1. 2021) is 2.6.11 so this should be ok.


## Creating a Bochs Disk Image

Now we have to create Bochs disk image where we will inject our MBR sample. Open
a new Administrator Command Prompt window. In the Administrator Command Prompt window, navigate to install directory of
Bochs emulator and run these commands to create Bochs Disk image:

**cd C:\\Program Files\\Bochs-2.6.11**

**bximage.exe**

The "bximage" tool launches, as shown below.

Enter these items:

-   **1** to create a new image
-   **Enter** for "hd"
-   **Enter** for "flat"
-   **Enter** for 512 byte hard disk sectors
-   **Enter** for size "10"
-   **Enter** to accept the default name or rename to " my_new_image_.img"
-   **Enter** to continue and exit bximage

![](media/fa4ff52486cacc090e084d21e1502409.png)


## Creating the Configuration File

In the Administrator Command Prompt window, execute these commands:

**notepad bochsrc.bxrc**

A Notepad box pops up, asking if we want to create a new file.

Click **Yes**.

Enter this text into Notepad, as shown below.

**megs: 512**<br/>
**romimage: file="BIOS-bochs-latest"**<br/>
**vgaromimage: file="VGABIOS-lgpl-latest"**<br/>
**boot: cdrom, disk**<br/>
**ata0-master: type=disk, path="my_new_image_.img", mode=flat**<br/>
**mouse: enabled=0**<br/>
**cpu: ips=90000000**<br/>
<br/>
If this config is too slow, try to change:<br/>
**boot: disk**<br/>
**cpu: ips=3000000**<br/>
Sometimes less is better...
Be careful on the “path” parameter – must match the name we chase during image
creation.

![](media/fa702161a7888d0627af1120e8dc3b72.png)

In Notepad, click **File**, **Save**. Close Notepad.<br/>
<br/>
## Injecting MBR in newly created Bochs Disk Image

When we are injecting our MBR bin file we are simply replacing first 512 bytes
of created Bochs image “my_new_image_.img” with 512 bytes of our MBR. We can do
this in any HEX editor or simply with python as you can see in the picture
below.

![](media/dcab4a53523da9de90bbc9c73f5ca8dd.png)

We can check that 512 bytes of MBR were really injected in Bochs Disk Image in
Hex editor:

![](media/5a10df9dbd628c351ba34372d158b424.png)

Opening previously created configuration file “bochsrc.bxrc” in IDA.

![](media/d02e64045555f14a5f0dd0b8a01ff919.png)

![](media/57746bfcbd93b3112cedbd0899c93bdf.png)

![](media/92d2ad0a7bf126746f7fc4b43cac343c.png)


If IDA got a problem with locating the Bochs debugger “bochsdbg.exe”, check the dbg_bochs.cfg in location
(“IDA install directory\\cfg\\dbg_bochs.cfg”) and modify the (BOCHSDBG =
"C:\\\\Program Files\\\\Bochs-2.6.11\\\\bochsdbg.exe";) to point to the location
where we installed the Bochs emulator.

![](media/ad3056ad1c1baaaa4efe3bf2484128dc.png)

We do not have to bother with the line “//BOCHSRC = "c:\\\\program files\\\\IDA
Pro 7.5\\\\cfg\\\\bochsrc.cfg";” because we already gave IDA the Bochs
configuration file as “bochsrc.bxrc”.


## Let´s start debugging

Put a breakpoint on the start address „BOOT_SECTOR:7C00“. Don´t be surprised
about the 0x7C00 address – little explanation:

A bootloader runs under certain conditions. The following pertains to
bootloaders initiated by the PC BIOS:

-   The first sector of a drive contains its boot loader.

-   One sector is usually 512 bytes — the last two bytes must be 0xAA55 (i.e.
    0x55 followed by 0xAA), or else the BIOS will treat the drive as unbootable.

-   If everything is in order, said first sector will be placed at RAM address
    0000:7C00, and the BIOS's role is over as it transfers control to 0000:7C00.
    (I.e. it JMPs to that address)

IDA sets almost everything for us automatically after opening “bochsrc.bxrc”
file but in case we would not like to use the Bochs configuration file and want
to analyze the bootstrap code of MBR alone just remember to load it as x86 16
bit LE code.


Start debugging:

![](media/f7cdab41cbc7432af984b5e8a88b3ac3.png)

![](media/886319836154ee486f481e3921c85a2c.png)

Now we are in state of debugging bootstrap code of MBR so next section will be
focusing on solving the challenge “The Proclamation” of CrowdStrike Intelligence
Adversary Quest [[CrowdStrike Intelligence Adversary
Quest]](https://www.crowdstrike.com/blog/join-crowdstrike-intelligence-adversary-quest/)
CTF.

MBR to download from this challenge is available here [[MBR
sample]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/Debugging%20MBR%20-%20IDA%20%2B%20Bochs%20Emulator/My_MBR).


## Analyzing and solving challenge “The Proclamation”

At first, when we reach breakpoint on the start address 0x7C00, we can see two
interrupts and calling function sub_7C1B.

These two interrupts are only setting cursor position and color of the
background and foreground text which will be printed as it is described in the
picture below.

![](media/88fb85b74afe5e319a1da52b23bef69d.png)

IDA already helped us a lot with arguments description. But for sure, below is more information to INT 10h / AH =
07h

![](media/50865ce90a76f4b90d8c6bd5da6c5b0e.png)

For BH value as attribute is table explaining this value below.

![](media/f01b140cacf760f6943dbe545fde1cd1.png)

So the background color is set to Dark grey and foreground color is set to light
green. Cursor position is upper left. Let’s move on to analyzing function
sub_7C1B.

In sub_7C1B we can immediately see some XOR routine.

![](media/5ad254ea2462aeeb571ea380ad12876c.png)

This function is basically
reading byte after byte from some offset and decrypt it via XOR routine. If
decrypted byte is 00, the XOR routine ends – function ends. If decrypted byte is
0A, another 2 interrupts occur. These interrupts behave as new line creator
which read current cursor position and set cursor position on new line. If
decrypted byte is not 00 or 0A, another interrupt occurs – int 10h, ah = 0E -->
Prints character on screen (this interrupt is described below). All this routine
we can see annotated:

![](media/0a446c6f272ca6771e26d4c169a02b01.png)

Description “int 10h, ah = 0E”:

![](media/f1f3e0996d1bdb77365f86701db51187.png)

We can clearly see that first byte which will be decrypted on address 0x7C78,
the value of this byte is 2E:

![](media/cd990976445912dc268c870b6819009f.png)

Let´s put a breakpoint on the jump address when decrypted byte is 00 (loc_7C5F).
After we continue debugging, we can see that decrypted text is printed on the
screen.

![](media/c681797e27f7f18c52c60e8080a9d016.png)

But as we can see, the flag is somehow missing. Let´s note the SI value = 0x7DCA
which is pointing on the next byte which could be decrypted if decrypted byte 00
did not occur.

The main point is that there is more data to be decrypted after decrypted byte
00 which ends our decryption function. Restart the debugging and put a
conditional breakpoint on address 0x7C44 (SI==0x7DCA), where conditional jump
occurs and is done if decrypted byte is 00.

Setting the conditional breakpoint on address 0x7C44 when value of SI register is 0x7DCA:

![](media/a80190e0976faeb60ae20da5fab2aade.png)

Continue debugging. We reached our conditional breakpoint. We can clearly see that there is more data which
could be decrypted in the picture below (check the VA address 0x7DCA).

![](media/c78574a4d40b8d2790ed7fe4779b173c.png)

When we want to continue in decryption routine, we can simply change the value of ZF =0 and not performing
jump to the function end. Press continue and check the output in Bochs emulator display.

![](media/f04003d01d8f839f68adbc38007c4db4.png)

And here it is - CS{0rd3r_0f_0x20_b00tl0ad3r} – Our winning flag.

## Author:

[[Twitter]](https://twitter.com/vinopaljiri)

[[Github]](https://github.com/Dump-GUY)

## Download:

[[Download PDF]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/Debugging%20MBR%20-%20IDA%20%2B%20Bochs%20Emulator/Debugging%20MBR%20-%20IDA%20%2B%20Bochs%20Emulator.pdf) 
